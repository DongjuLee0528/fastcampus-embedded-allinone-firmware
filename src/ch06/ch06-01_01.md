# Timer/Counter Ext_Falling 이론 총정리

---

## 1) Timer/Counter란?

- **Timer**는 내부 클럭을 사용하여 일정 시간 간격의 펄스를 만들어 내거나 일정 시간 경과 후에 인터럽트를 발생시키는 기능을 말한다.
- **Counter**는 외부(TOSC1, TOSC2, T1, T2, T3)을 통해서 들어오는 펄스를 계수하여 Event Counter로서 동작되는 것을 말한다.

> *입력소스는 다르지만 사용목적과 결과가 같기 때문에, 혼용되어 사용된다.*

### 타이머/카운터 동작 과정
```
내부클럭(동기)  ─┐
                 ├─→ Prescaler ─→ Control Logic ─→ OVF   : 0x00~0xff로 카운트 후 overflow되면 인터럽트 발생
외부클럭(비동기) ─┘                               └─→ COMP  : OCR 값과 비교하여 매치되면 인터럽트 발생
```

---

## 2) Timer/Counter의 활용 모드

- **Normal 모드** → 순수 Timer/Counter용으로 파형을 생성하지 않음
- **PWM 모드** → 파형을 일정한 주기로 출력
  - ex) 모터 속도조절, LED 밝기 조절 등에 사용
- **CTC 모드 (Clear Timer on Compare Match)** → 원하는 주파수를 생성
  - ex) 시계, 멜로디 발생 등에 사용
- **OVF 인터럽트 (Overflow)** → TCNT가 가득 차면 OVF Interrupt 발생
- **OCM 인터럽트 (Output Compare Match)** → TCNT와 특정 값이 같아지면 인터럽트 발생

---

## 3) Timer vs Counter 핵심 차이점

| 구분 | 타이머 (Timer) | 카운터 (Counter) |
|------|--------------|----------------|
| 클럭 소스 | 내부 클럭 (CPU 클럭) | 외부 핀 입력 (T0, T1 핀) |
| 속도 | 빠름 (최대 16MHz) | 느림 (외부 신호 속도에 종속) |
| 분주 (Prescaler) | 가능 (1, 8, 64, 256, 1024) | 불가능 |
| 클럭 선택 | 분주비로 원하는 속도 선택 가능 | 외부 클럭 그대로만 사용 |
| 동기/비동기 | 동기 모드 (CPU와 같은 클럭) | 비동기 모드 (CPU와 독립적) |
| 주요 목적 | 시간 측정, 주기적 작업 | 외부 이벤트 횟수 카운트 |

---

## 4) 타이머 (Timer) 상세

### 동작 원리

- CPU 내부 클럭(16MHz)을 Prescaler로 분주하여 사용
- 분주비에 따라 카운트 속도 조절 가능
```
CPU 클럭 16MHz
    ↓ Prescaler (÷1, ÷8, ÷64, ÷256, ÷1024)
    ↓ 원하는 속도로 TCNT 증가
    ↓ Overflow or Compare Match
    → 인터럽트 발생
```

### 분주비별 타이머 주기 예시 (16MHz 기준, 8bit 타이머)

| Prescaler | 클럭 주기 | 최대 시간 (256 카운트) |
|-----------|---------|-------------------|
| 1 | 62.5ns | 16µs |
| 8 | 500ns | 128µs |
| 64 | 4µs | 1.024ms |
| 256 | 16µs | 4.096ms |
| 1024 | 64µs | 16.384ms |

### 타이머 사용 예시

**① 1초마다 LED 깜빡이기**
```c
// 1초 주기가 필요 → 내부 클럭으로 정확한 시간 측정
// Prescaler 1024, 16MHz → 오버플로우 계산으로 1초 구현
TCCR0B |= (1 << CS02) | (1 << CS00); // Prescaler 1024
TIMSK0 |= (1 << TOIE0);              // 오버플로우 인터럽트 활성화
```

**② 서보모터 PWM 제어 (20ms 주기)**
```c
// 정확한 20ms 주기 필요 → 타이머로 PWM 생성
TCCR1A |= (1 << WGM11);
TCCR1B |= (1 << WGM13) | (1 << CS11); // Prescaler 8
ICR1 = 39999; // 20ms 주기
```

**③ 시계 구현 (1초 타이머)**
```c
// 1ms마다 인터럽트 → 변수로 시/분/초 관리
// 정확한 시간 측정이 필요 → 반드시 타이머 사용
```

---

## 5) 카운터 (Counter) 상세

### 동작 원리

- 외부 핀(T0=PD4, T1=PD5)으로 들어오는 신호의 엣지를 카운트
- Rising Edge(상승) 또는 Falling Edge(하강) 선택 가능
- CPU 클럭과 무관하게 비동기로 동작
```
외부 신호 (버튼, 센서, 엔코더 등)
    ↓ T0 또는 T1 핀 입력
    ↓ Rising/Falling Edge 감지
    ↓ TCNT 증가
    → Overflow or Compare Match → 인터럽트 발생
```

### 카운터 사용 예시

**① 공장 컨베이어벨트 제품 개수 세기**
```c
// 물체가 센서를 지날 때마다 펄스 발생 → 카운터 사용
TCCR0A = 0x00;
TCCR0B |= (1 << CS02) | (1 << CS01); // 외부 클럭, Falling Edge
TIMSK0 |= (1 << TOIE0);
```

**② 회전수(RPM) 측정**
```c
// 모터 엔코더 펄스 카운트 → T1 핀으로 엔코더 신호 입력
TCCR1B |= (1 << CS12) | (1 << CS11); // 외부 클럭, Falling Edge
```

**③ 버튼 누른 횟수 카운트**
```c
// 버튼을 몇 번 눌렀는지 하드웨어적으로 카운트
// 소프트웨어 처리 부담 없이 자동으로 카운트
```

---

## 6) 사용 기준 한눈에 보기
```
"시간이 중요한가?"
    ↓ YES → 타이머 사용
    ↓ NO  → 카운터 사용

"외부 이벤트 횟수가 중요한가?"
    ↓ YES → 카운터 사용
    ↓ NO  → 타이머 사용
```

| 상황 | 선택 | 이유 |
|------|------|------|
| 1초마다 센서 데이터 읽기 | 타이머 | 정확한 시간 간격 필요 |
| 모터 RPM 측정 | 카운터 | 외부 펄스 횟수 카운트 |
| LED 점멸 주기 제어 | 타이머 | 내부 클럭으로 정밀 시간 제어 |
| 공장 제품 개수 세기 | 카운터 | 외부 센서 신호 카운트 |
| 서보모터 PWM 생성 | 타이머 | 정확한 주기 생성 필요 |
| 버튼 클릭 횟수 기록 | 카운터 | 외부 이벤트 횟수 측정 |
| 초음파 거리 측정 | 타이머 | 시간 측정으로 거리 계산 |
| 풍속계 회전 측정 | 카운터 | 회전 횟수로 풍속 계산 |

---

## 7) 내용 정리

1. 타이머는 **내부 클럭**으로 시간을 측정하고, 카운터는 **외부 신호**로 사건의 횟수를 센다.
2. 타이머는 **최댓값**에 도달하면 **'오버플로우'** 이벤트를, **특정 값**과 일치하면 **'비교 매치'** 이벤트를 발생시킨다.
3. 이를 활용한 **Normal, CTC, PWM** 모드를 통해 주기적인 **작업 수행**, **정밀 주파수 생성**, **모터 제어** 등이 가능하다.

---

> **타이머** = "얼마나 지났나?" → 시간 기반 작업  
> **카운터** = "몇 번 일어났나?" → 이벤트 기반 작업